using Foxy.Params.SourceGenerator.Data;
using Foxy.Params.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Foxy.Params.SourceGenerator.SourceGenerator
{
    internal class OverridesGenerator
    {
        private readonly SourceBuilder _sourceBuilder;
        private readonly INamedTypeSymbol _typeInfo;
        private readonly IEnumerable<SuccessfulParamsCandidate> _paramsCandidates;
        private readonly int _maxOverridesMax;

        public OverridesGenerator(INamedTypeSymbol typeInfo, IEnumerable<SuccessfulParamsCandidate> paramsCandidates)
        {
            _sourceBuilder = new SourceBuilder();
            _typeInfo = typeInfo ?? throw new ArgumentNullException(nameof(typeInfo));
            _paramsCandidates = paramsCandidates ?? throw new ArgumentNullException(nameof(paramsCandidates));
            _maxOverridesMax = paramsCandidates.Max(e => e.MaxOverrides);
        }

        public SourceText Execute()
        {
            _sourceBuilder.Clear();
            _sourceBuilder.AppendTrivias(
                AutoGeneratedComment(),
                CarriageReturnLineFeed,
                NullableEnable(),
                CarriageReturnLineFeed);
            GenerateNamespace();

            return SourceText.From(_sourceBuilder.ToString(), Encoding.UTF8);
        }

        private static SyntaxTrivia AutoGeneratedComment()
        {
            return Comment("// <auto-generated />");
        }

        private static SyntaxTrivia NullableEnable()
        {
            return Trivia(
                NullableDirectiveTrivia(
                    Token(TriviaList(Space), SyntaxKind.EnableKeyword, TriviaList()),
                    true));
        }

        private void GenerateNamespace()
        {
            AddNamespace(_sourceBuilder, _typeInfo);

            GeneratePartialClass();
            GenerateArgumentsClasses();

            AddNamespaceCloseBlock(_sourceBuilder, _typeInfo);
        }

        private void GeneratePartialClass()
        {
            var nestLevel = CreateClasses(_typeInfo, _sourceBuilder);

            foreach (var paramsCandidate in _paramsCandidates)
            {
                var data = new DerivedData(paramsCandidate);

                for (int n = 1; n <= paramsCandidate.MaxOverrides; n++)
                {
                    if (n > 1)
                    {
                        _sourceBuilder.AppendLine();
                    }

                    GenerateMethodOverrideWithNArgs(data, n);
                }

                GenerateOverrideWithParamsParameter(paramsCandidate, data);
            }

            CloseTimes(_sourceBuilder, nestLevel);
        }

        private static int CreateClasses(INamedTypeSymbol? typeInfo, SourceBuilder sb)
        {
            var items = SemanticHelpers.GetTypeHierarchy(typeInfo);
            foreach (var item in items)
            {
                sb.Class(item.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
            }

            return items.Count;
        }

        private static void CloseTimes(SourceBuilder sb, int nestLevel)
        {
            for (int i = 0; i < nestLevel; i++)
            {
                sb.CloseBlock();
            }
        }

        private void GenerateMethodOverrideWithNArgs(DerivedData data, int argsCount)
        {
            var variableArguments = data.FixArguments.Concat(
                Enumerable.Range(0, argsCount).Select(j => $"{data.SpanArgumentType} {data.ArgName}{j}"));
            GenerateMethodHeaderWithArguments(data, variableArguments);
            GenerateBodyForOverrideWithNArgs(data, argsCount);
            _sourceBuilder.CloseBlock();
        }

        private void GenerateMethodHeaderWithArguments(DerivedData data, IEnumerable<string> arguments)
        {
            _sourceBuilder.Method(
                data.MethodName,
                arguments,
                data.IsStatic,
                data.ReturnType,
                data.TypeArguments,
                data.TypeConstraints);
        }

        private void GenerateBodyForOverrideWithNArgs(DerivedData data, int argsCount)
        {
            GenerateArgumentsVariable(data, argsCount);
            GenerateSpanVariableForInlineArray(data, argsCount);
            GenerateCallOriginalMethod(data);
        }

        private void GenerateSpanVariableForInlineArray(DerivedData data, int argsCount)
        {
            _sourceBuilder.AppendLine($"var {data.ArgNameSpan} = global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref {data.ArgName}.arg0, {argsCount});");
        }

        private void GenerateArgumentsVariable(DerivedData data, int argsCount)
        {
            _sourceBuilder.AppendLine($"var {data.ArgName} = new Arguments{argsCount}<{data.SpanArgumentType}>({string.Join(", ", Enumerable.Range(0, argsCount).Select(j => $"{data.ArgName}{j}"))});");
        }

        private void GenerateOverrideWithParamsParameter(SuccessfulParamsCandidate paramsCandidate, DerivedData data)
        {
            if (!paramsCandidate.HasParams)
            {
                return;
            }
            _sourceBuilder.AppendLine();
            GenerateMethodHeaderWithArguments(data, data.FixArguments.Append($"params {data.SpanArgumentType}[] {data.ArgName}"));
            GenerateBodyWithParamsParameter(data);
            _sourceBuilder.CloseBlock();
        }

        private void GenerateBodyWithParamsParameter(DerivedData data)
        {
            GenerateSpanVariableForParamsArgument(data);
            GenerateCallOriginalMethod(data);
        }

        private void GenerateSpanVariableForParamsArgument(DerivedData data)
        {
            _sourceBuilder.AppendLine($"var {data.ArgNameSpan} = new global::System.ReadOnlySpan<{data.SpanArgumentType}>({data.ArgName});");
        }

        private void GenerateArgumentsClasses()
        {
            for (int i = 1; i <= _maxOverridesMax; i++)
            {
                _sourceBuilder.AppendLine();
                CreateArguments(_sourceBuilder, i);
            }
        }

        private void GenerateCallOriginalMethod(DerivedData data)
        {
            var codeLine = _sourceBuilder.StartLine();
            if (data.ReturnsKind != ReturnKind.ReturnsVoid)
            {
                codeLine.Returns();
            }
            if (data.ReturnsKind == ReturnKind.ReturnsRef)
            {
                codeLine.AddSegment("ref ");
            }
            codeLine.AddSegment(data.MethodName);
            if (data.TypeArguments.Count > 0)
            {
                codeLine.AddSegment("<");
                codeLine.AddCommaSeparatedList(data.TypeArguments);
                codeLine.AddSegment(">");
            }
            codeLine.AddSegment("(");
            codeLine.AddCommaSeparatedList(data.ParameterInfos.Select(e => e.ToPassParameter()));
            codeLine.AddSegment($", {data.ArgNameSpanInput})");
            codeLine.EndLine();
        }

        private static void CreateArguments(SourceBuilder sb, int length)
        {
            sb.Attribute($"System.Runtime.CompilerServices.InlineArray({length})");
            sb.GenericStruct($"Arguments{length}", "T");
            sb.Field("T", "arg0");
            sb.AppendLine();
            sb.Constructor(Enumerable.Range(0, length).Select(e => $"T value{e}"));
            sb.AppendLine($"arg0 = value0;");
            for (int i = 1; i < length; i++)
            {
                sb.AppendLine($"this[{i}] = value{i};");
            }
            sb.CloseBlock();
            sb.CloseBlock();
        }

        private static void AddNamespace(SourceBuilder sb, INamedTypeSymbol typeInfo)
        {
            if (typeInfo.ContainingNamespace.IsGlobalNamespace)
                return;

            sb.Namespace(SemanticHelpers.GetNameSpaceNoGlobal(typeInfo));
        }

        private static void AddNamespaceCloseBlock(SourceBuilder sb, INamedTypeSymbol typeInfo)
        {
            if (typeInfo.ContainingNamespace.IsGlobalNamespace)
                return;

            sb.CloseBlock();
        }
    }
}
