using Foxy.Params.SourceGenerator.CodeElements;
using Foxy.Params.SourceGenerator.Data;
using Foxy.Params.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Foxy.Params.SourceGenerator.SourceGenerator
{
    internal class OverridesGenerator
    {
        private readonly INamedTypeSymbol _typeInfo;
        private readonly IEnumerable<SuccessfulParamsCandidate> _paramsCandidates;
        private readonly int _maxOverridesMax;
        private static readonly AdhocWorkspace _workspace = new AdhocWorkspace();

        public OverridesGenerator(INamedTypeSymbol typeInfo, IEnumerable<SuccessfulParamsCandidate> paramsCandidates)
        {
            _typeInfo = typeInfo ?? throw new ArgumentNullException(nameof(typeInfo));
            _paramsCandidates = paramsCandidates ?? throw new ArgumentNullException(nameof(paramsCandidates));
            _maxOverridesMax = paramsCandidates.Max(e => e.MaxOverrides);
        }

        public SourceText Execute()
        {
            SyntaxNode compliationUnit = CompilationUnit()
                .WithMembers(GenerateNamespace())
                .WithLeadingTrivia(AutoGeneratedComment(),
                            CarriageReturnLineFeed,
                            CarriageReturnLineFeed,
                            NullableEnable(),
                            CarriageReturnLineFeed,
                            CarriageReturnLineFeed)
                .WithTrailingTrivia(CarriageReturnLineFeed);
            compliationUnit = Formatter.Format(compliationUnit, _workspace);
            
            return compliationUnit.GetText(Encoding.UTF8);
        }

        private static SyntaxTrivia AutoGeneratedComment()
        {
            return Comment("// <auto-generated />");
        }

        private static SyntaxTrivia NullableEnable()
        {
            return Trivia(
                NullableDirectiveTrivia(
                    Token(TriviaList(Space), SyntaxKind.EnableKeyword, TriviaList()),
                    true));
        }

        private SyntaxList<MemberDeclarationSyntax> GenerateNamespace()
        {
            if(!_typeInfo.ContainingNamespace.IsGlobalNamespace)
            {
                return SingletonList<MemberDeclarationSyntax>(
                    AddNamespace(_typeInfo.ContainingNamespace)
                    .WithMembers(List(GenerateNamespaceMembers())));
            }

            return List(GenerateNamespaceMembers());

            IEnumerable<MemberDeclarationSyntax> GenerateNamespaceMembers()
            {
                yield return GeneratePartialClass();
                foreach (var argumentClass in GenerateArgumentsClasses())
                {
                    yield return argumentClass;
                }
            }
        }

        private ClassDeclarationSyntax GeneratePartialClass()
        {
            return CreateClasses(_typeInfo, List(Members()));

            IEnumerable<MemberDeclarationSyntax> Members()
            {
                foreach (var paramsCandidate in _paramsCandidates)
                {
                    var data = new DerivedData(paramsCandidate);

                    for (int n = 1; n <= paramsCandidate.MaxOverrides; n++)
                    {
                        yield return GenerateMethodOverrideWithNArgs(data, n).WithTrailingTrivia(CarriageReturnLineFeed);
                    }

                    if (paramsCandidate.HasParams)
                    {
                        yield return GenerateOverrideWithParamsParameter(paramsCandidate, data);
                    }
                }
            }
        }

        private ClassDeclarationSyntax CreateClasses(INamedTypeSymbol typeInfo, SyntaxList<MemberDeclarationSyntax> members)
        {
            var classSyn = ClassDeclaration(
                attributeLists: default,
                modifiers: TokenDef.Partial(),
                identifier: Identifier(typeInfo.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)),
                typeParameterList: default,
                baseList: default,
                constraintClauses: default,
                members: members
                );

            if (typeInfo.ContainingType is not null)
            {
                return CreateClasses(typeInfo.ContainingType, SingletonList<MemberDeclarationSyntax>(classSyn));
            }

            return classSyn;
        }

        private MethodDeclarationSyntax GenerateMethodOverrideWithNArgs(DerivedData data, int argsCount)
        {
            var variableArguments = data.FixArguments.Concat(
                Enumerable.Range(0, argsCount).Select(j => $"{data.SpanArgumentType} {data.ArgName}{j}"));
            var method = GenerateMethodHeaderWithArguments(data, NArgs(argsCount));
            method = method.WithBody(GenerateBodyForOverrideWithNArgs(data, argsCount));
            return method;

            IEnumerable<ParameterSyntax> NArgs(int argsCount)
            {
                var spanArgType = ParseTypeName(data.SpanArgumentType);
                for (int i = 0; i < argsCount; i++)
                {
                    yield return ParamDecl.Of(spanArgType, $"{data.ArgName}{i}");
                }
            }
        }

        private MethodDeclarationSyntax GenerateMethodHeaderWithArguments(DerivedData data, IEnumerable<ParameterSyntax> additional)
        {
            var method = MethodDeclaration(
                ParseTypeName(data.ReturnType),
                Identifier(data.MethodName));
            method = method.WithModifiers(TokenList(Modifiers(data.IsStatic)));
            if (data.TypeArguments.Count > 0)
            {
                method = method.WithTypeParameterList(TypeParameterList(SeparatedList(TypeParameters(data.TypeArguments))));
            }
            method = method.WithParameterList(ParameterList(SeparatedList(
                FixedParameters(data).Concat(additional))));
            if (data.TypeConstraints.Count > 0)
            {
                method = method.WithConstraintClauses(List(Constraints(data)));
            }

            return method;

            static IEnumerable<SyntaxToken> Modifiers(bool isStatic)
            {
                yield return Token(SyntaxKind.PublicKeyword);
                if (isStatic)
                {
                    yield return Token(SyntaxKind.StaticKeyword);
                }
            }

            static IEnumerable<TypeParameterSyntax> TypeParameters(IEnumerable<string> typeArguments)
            {
                foreach (var item in typeArguments)
                {
                    yield return TypeParameter(item);
                }
            }

            static IEnumerable<ParameterSyntax> FixedParameters(DerivedData data)
            {
                foreach (var item in data.ParameterInfos)
                {
                    var type = ParseTypeName(item.Type);
                    type = item.IsNullable ? NullableType(type) : type;
                    yield return ParamDecl.Of(TokenDef.Of(item.RefKind), type, item.Name);
                }
            }

            static IEnumerable<TypeParameterConstraintClauseSyntax> Constraints(DerivedData data)
            {
                foreach (var constrain in data.TypeConstraints)
                {
                    yield return TypeParameterConstraintClause(IdentifierName(constrain.Type),
                        SeparatedList(ConstraintsElements(constrain.Constraints)));
                }
            }

            static IEnumerable<TypeParameterConstraintSyntax> ConstraintsElements(List<string> constraints)
            {
                foreach (var item in constraints)
                {
                    switch (item)
                    {
                        case "struct":
                            yield return ClassOrStructConstraint(SyntaxKind.StructConstraint);
                            break;
                        case "class":
                            yield return ClassOrStructConstraint(SyntaxKind.ClassConstraint);
                            break;
                        case "notnull":
                            yield return TypeConstraint(IdentifierName("notnull"));
                            break;
                        case "unmanaged":
                            yield return TypeConstraint(IdentifierName("unmanaged"));
                            break;
                        case "new()":
                            yield return ConstructorConstraint();
                            break;
                        default:
                            yield return TypeConstraint(ParseTypeName(item));
                            break;
                    }
                }
            }
        }

        private BlockSyntax GenerateBodyForOverrideWithNArgs(DerivedData data, int argsCount)
        {
            return Block(
                GenerateArgumentsVariable(data, argsCount),
                GenerateSpanVariableForInlineArray(data, argsCount),
                GenerateCallOriginalMethod(data));
        }


        /// <summary>
        /// var argsSpan = global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref arg.arg0, argsCount);
        /// </summary>
        private LocalDeclarationStatementSyntax GenerateSpanVariableForInlineArray(DerivedData data, int argsCount)
        {
            return Line.Var(data.ArgNameSpan, CallCreateReadOnlySpan(data.ArgName, argsCount));
        }

        /// <summary>
        /// global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref args.arg0, 1)
        /// </summary>
        private ExpressionSyntax CallCreateReadOnlySpan(string argName, int argsCount)
        {
            return InvocationExpression(
                TypeDef.Global("System", "Runtime", "InteropServices", "MemoryMarshal", "CreateReadOnlySpan"),
                ArgumentDecl.List(
                    ArgumentDecl.Ref(TypeDef.Of(argName, "arg0")),
                    Argument(Literals.Value(argsCount)))
                );
        }

        /// <summary>
        /// var {argName} = new Arguments{argsCount}&lt;{SpanArgumentType}&gt;(argName1, argName2, argName3);
        /// </summary>
        private LocalDeclarationStatementSyntax GenerateArgumentsVariable(DerivedData data, int argsCount)
        {
            return Line.Var(data.ArgName,
                Constructor.New(
                    TypeDef.Of([$"Arguments{argsCount}"], ParseTypeName(data.SpanArgumentType)),
                    Arguments(argsCount, data.ArgName)
                    ));

            static IEnumerable<ArgumentSyntax> Arguments(int argsCount, string argNamePrefix)
            {
                for (var i = 0; i < argsCount; i++)
                {
                    yield return ArgumentDecl.Of($"{argNamePrefix}{i}");
                }
            }
        }

        private MethodDeclarationSyntax GenerateOverrideWithParamsParameter(SuccessfulParamsCandidate paramsCandidate, DerivedData data)
        {
            var method = GenerateMethodHeaderWithArguments(data, SpanArgument(data));
            method = method.WithBody(GenerateBodyWithParamsParameter(data));
            return method;

            static IEnumerable<ParameterSyntax> SpanArgument(DerivedData data)
            {
                TypeSyntax elementType = ParseTypeName(data.SpanArgumentType);
                yield return ParamDecl.Of(TokenDef.Params(), TypeDef.Array(elementType), data.ArgName);
            }
        }

        private BlockSyntax GenerateBodyWithParamsParameter(DerivedData data)
        {
            return Block(
                GenerateSpanVariableForParamsArgument(data),
                GenerateCallOriginalMethod(data)
                );
        }

        /// <summary>
        /// var argsSpan = new global::System.ReadOnlySpan<T>(args);
        /// </summary>
        private LocalDeclarationStatementSyntax GenerateSpanVariableForParamsArgument(DerivedData data)
        {
            return Line.Var(
                data.ArgNameSpan,
                NewReadOnlySpanOfTWithArgs(data.SpanArgumentType, data.ArgName));
        }

        /// <summary>
        /// new global::System.ReadOnlySpan&lt;T&gt;(argName)
        /// </summary>
        private static ObjectCreationExpressionSyntax NewReadOnlySpanOfTWithArgs(string spanArgumentType, string argName)
        {
            return Constructor.New(
                TypeDef.Global(["System", "ReadOnlySpan"], ParseTypeName(spanArgumentType)),
                ArgumentDecl.Of(argName));
        }

        /// <summary>
        /// {typeParameterName}
        /// </summary>
        private static TypeParameterListSyntax TypeParameters(string typeParameterName)
        {
            return TypeParameterList(SingletonSeparatedList(TypeParameter(typeParameterName)));
        }

        private IEnumerable<MemberDeclarationSyntax> GenerateArgumentsClasses()
        {
            for (int i = 1; i <= _maxOverridesMax; i++)
            {
                yield return CreateArgumentsStruct(i);
            }
        }

        /// <summary>
        /// return Format<{T}>({format}, {argsSpan})
        /// </summary>
        private StatementSyntax GenerateCallOriginalMethod(DerivedData data)
        {
            SimpleNameSyntax methodName = data.TypeArguments.Count > 0
                ? GenericName(Identifier(data.MethodName), TypeArgumentList(SeparatedList(GenerateInvocationTypeArguments(data))))
                : IdentifierName(data.MethodName);
            var invocationExpression = InvocationExpression(
                methodName,
                ArgumentList(SeparatedList(GenerateInvocationArguments(data))));
            return AddReturnStatement(data.ReturnsKind, invocationExpression);
        }

        /// <summary>
        /// <code>Format()</code> 
        /// or
        /// <code>return Format()</code>
        /// or
        /// <code>return ref Format()</code>
        /// </summary>
        private static StatementSyntax AddReturnStatement(ReturnKind returnKind, ExpressionSyntax invocationExpression)
        {
            if (returnKind == ReturnKind.ReturnsRef)
            {
                invocationExpression = RefExpression(invocationExpression);
            }
            return returnKind != ReturnKind.ReturnsVoid
                ? ReturnStatement(invocationExpression)
                : ExpressionStatement(invocationExpression);
        }

        private IEnumerable<TypeSyntax> GenerateInvocationTypeArguments(DerivedData data)
        {
            foreach (var item in data.TypeArguments)
            {
                yield return IdentifierName(item);
            }
        }

        private IEnumerable<ArgumentSyntax> GenerateInvocationArguments(DerivedData data)
        {
            foreach (var item in data.ParameterInfos)
            {
                yield return item.GetPassParameterModifier() switch
                {
                    RefKind.Ref => ArgumentDecl.Ref(IdentifierName(item.Name)),
                    RefKind.Out => ArgumentDecl.Out(IdentifierName(item.Name)),
                    RefKind.In => ArgumentDecl.In(IdentifierName(item.Name)),
                    _ => ArgumentDecl.Of(item.Name)
                };
            }
            yield return ArgumentDecl.Of(data.ArgNameSpanInput);
        }

        private StructDeclarationSyntax CreateArgumentsStruct(int length)
        {
            var typeName = Identifier($"Arguments{length}");
            var argumentsStruct = StructDeclaration(
                attributeLists: Attributes.List(InlineArrayAttribute(length)),
                modifiers: Modifier.File(),
                identifier: typeName,
                typeParameterList: TypeParameters("T"),
                baseList: default,
                constraintClauses: default,
                members: ArgumentsStructMembers(length, typeName));
            return argumentsStruct;
        }

        private static SyntaxList<MemberDeclarationSyntax> ArgumentsStructMembers(int length, SyntaxToken typeName)
        {
            return List(ArgumentsStructMembers(typeName, length));

            static IEnumerable<MemberDeclarationSyntax> ArgumentsStructMembers(SyntaxToken typeName, int argumentsCount)
            {
                yield return Field.Public(IdentifierName("T"), "arg0");
                yield return CtorArguments(typeName, argumentsCount);
            }

        }

        private static MemberDeclarationSyntax CtorArguments(SyntaxToken typeName, int argumentsCount)
        {
            return ConstructorDeclaration(
                attributeLists: default,
                modifiers: Modifier.Public(),
                identifier: typeName,
                parameterList: ArgumentsTypeCtorParameters(argumentsCount),
                initializer: default,
                body: ArgumentsTypeCtorBody(argumentsCount));
        }

        private static ParameterListSyntax ArgumentsTypeCtorParameters(int argumentsCount)
        {
            return ParameterList(SeparatedList(ArgumentsTypeCtorEnumerator(argumentsCount)));

            static IEnumerable<ParameterSyntax>? ArgumentsTypeCtorEnumerator(int argumentsCount)
            {
                for (int i = 0; i < argumentsCount; i++)
                {
                    yield return Parameter(Identifier($"value{i}"))
                        .WithType(IdentifierName("T"));
                }
            }
        }

        private static BlockSyntax ArgumentsTypeCtorBody(int argumentsCount)
        {
            return Block(ArgumentsTypeCtorBodyEnumerator(argumentsCount));

            static IEnumerable<StatementSyntax> ArgumentsTypeCtorBodyEnumerator(int argumentsCount)
            {
                yield return Line.Assign(IdentifierName("arg0"), IdentifierName("value0"));
                for (int i = 1; i < argumentsCount; i++)
                {
                    yield return Line.Assign(
                        ElementAccessExpression(ThisExpression(), Indexers.Indexer(i)),
                        IdentifierName($"value{i}"));
                }
            }
        }

        /// <summary>
        /// [global::System.Runtime.CompilerServices.InlineArray(length)]<br/>
        /// ?
        /// </summary>
        private static AttributeSyntax InlineArrayAttribute(int length)
        {
            return Attribute(
                TypeDef.Global("System", "Runtime", "CompilerServices", "InlineArray"),
                AttributeArgumentList(SingletonSeparatedList(AttributeArgument(Literals.Value(length))
                )));
        }

        private NamespaceDeclarationSyntax AddNamespace(INamespaceSymbol namespaceInfo)
        {
            return NamespaceDeclaration(GetNameSpaceName(namespaceInfo));
            
            static NameSyntax GetNameSpaceName(INamespaceSymbol namespaceInfo)
            {
                if(namespaceInfo.ContainingNamespace == null || namespaceInfo.ContainingNamespace.IsGlobalNamespace)
                {
                    return IdentifierName(namespaceInfo.Name);
                }
                return QualifiedName(GetNameSpaceName(namespaceInfo.ContainingNamespace), IdentifierName(namespaceInfo.Name));
            }
        }
    }
}
