using Foxy.Params.SourceGenerator.Data;
using Foxy.Params.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Foxy.Params.SourceGenerator.SourceGenerator;

internal class OverridesGenerator : IDisposable
{
    private readonly SourceBuilder _builder = SourceBuilderPool.Instance.Get();
    private readonly int _maxOverridesMax;
    private readonly SuccessfulParams[] _paramsCandidates;
    private readonly CandidateTypeInfo _typeInfo;

    public OverridesGenerator(CandidateTypeInfo typeInfo, SuccessfulParams[] paramsCandidates)
    {
        _typeInfo = typeInfo ?? throw new ArgumentNullException(nameof(typeInfo));
        _paramsCandidates = paramsCandidates ?? throw new ArgumentNullException(nameof(paramsCandidates));
        _maxOverridesMax = paramsCandidates.Max(static e => e.MaxOverrides);
    }

    public void Dispose()
    {
        SourceBuilderPool.Instance.Return(_builder);
    }

    public SourceText Execute()
    {
        _builder.AddAutoGeneratedComment();
        _builder.AppendLine();
        _builder.AddNullableEnable();
        _builder.AppendLine();
        GenerateNamespace();

        return SourceText.From(_builder.ToString(), Encoding.UTF8);
    }

    private void GenerateNamespace()
    {
        if (_typeInfo.InGlobalNamespace)
        {
            GenerateNamespaceMembers();
        }
        else
        {
            var namespaceName = _typeInfo.Namespace;
            _builder.AppendLine($"namespace {namespaceName}");
            using (_builder.StartBlock())
            {
                GenerateNamespaceMembers();
            }
        }
    }

    private void GenerateNamespaceMembers()
    {
        GeneratePartialClass(0);
        GenerateArgumentsClasses();
    }

    private void GeneratePartialClass(
        int level)
    {
        if (level < _typeInfo.TypeHierarchy.Length)
        {
            _builder.AppendLine($"partial class {_typeInfo.TypeHierarchy[level]}");
            using (_builder.StartBlock())
            {
                GeneratePartialClass(level + 1);
            }
        }
        else
        {
            foreach (var paramsCandidate in _paramsCandidates)
            {
                var data = paramsCandidate.MethodInfo;

                AddOverrideMethods(paramsCandidate, data);

                AddParamsMethod(paramsCandidate, data);
            }
        }
    }

    private void AddOverrideMethods(SuccessfulParams paramsCandidate, MethodInfo data)
    {
        for (int n = 1; n <= paramsCandidate.MaxOverrides; n++)
        {
            if (n > 1)
            {
                _builder.AppendLine();
            }

            var variableArguments = data.GetFixArguments().Concat(
                Enumerable.Range(0, n).Select(j => $"{data.SpanArgumentType} {data.GetArgName()}{j}"));
            GenerateMethodHeaderWithArguments(data, variableArguments);
            using (_builder.StartBlock())
            {
                GenerateBodyForOverrideWithNArgs(data, n);
            }
        }
    }

    private void AddParamsMethod(SuccessfulParams paramsCandidate, MethodInfo data)
    {
        if (!paramsCandidate.HasParams)
            return;

        _builder.AppendLine();
        var paramsArguments = data.GetFixArguments()
            .Append($"params {data.SpanArgumentType}[] {data.GetArgName()}");
        GenerateMethodHeaderWithArguments(data, paramsArguments);
        using (_builder.StartBlock())
        {
            GenerateBodyWithParamsParameter(data);
        }
    }

    private void GenerateMethodHeaderWithArguments(
        MethodInfo data,
        IEnumerable<string> arguments)
    {
        _builder.AddGeneratedCodeAttribute();
        using (var line = _builder.StartLine())
        {
            line.AddSegment("public");
            if (data.IsStatic)
            {
                line.AddSegment(" static");
            }

            line.AddFormatted($" {data.ReturnType} {data.MethodName}");
            AddTypeConstraints(data, line);
            line.AddFormatted($"({arguments})");
        }

        using (_builder.StartIndented())
        {
            foreach (var typeConstraints in data.TypeConstraints)
            {
                typeConstraints.WriteTo(_builder);
            }
        }
    }

    private static void AddTypeConstraints(in MethodInfo data, in SourceBuilder.SourceLine line)
    {
        if (data.TypeConstraints.Length <= 0)
            return;

        line.AddSegment("<");
        var commaSeparatedList = line.StartCommaSeparatedList();
        foreach (var item in data.TypeConstraints)
        {
            commaSeparatedList.AddElement(item.Type);
        }

        line.AddSegment(">");
    }

    private void GenerateBodyForOverrideWithNArgs(MethodInfo data, int argsCount)
    {
        GenerateArgumentsVariable(data, argsCount);
        GenerateSpanVariableForInlineArray(data, argsCount);
        GenerateCallOriginalMethod(data);
    }

    private void GenerateSpanVariableForInlineArray(MethodInfo data, int argsCount)
    {
        _builder.AppendLine(
            $"var {data.GetArgName()}Span = " +
            $"global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref {data.GetArgName()}.arg0, {argsCount});");
    }

    private void GenerateArgumentsVariable(MethodInfo data, int argsCount)
    {
        _builder.AppendLine(
            $"var {data.GetArgName()} = new Arguments{argsCount}<{data.SpanArgumentType}>" +
            $"({Enumerable.Range(0, argsCount).Select(j => $"{data.GetArgName()}{j}")});");
    }

    private void GenerateBodyWithParamsParameter(MethodInfo data)
    {
        GenerateSpanVariableForParamsArgument(data);
        GenerateCallOriginalMethod(data);
    }

    private void GenerateSpanVariableForParamsArgument(MethodInfo data)
    {
        _builder.AppendLine(
            $"var {data.GetArgName()}Span = new global::System.ReadOnlySpan" +
            $"<{data.SpanArgumentType}>({data.GetArgName()});");
    }

    private void GenerateArgumentsClasses()
    {
        for (int i = 1; i <= _maxOverridesMax; i++)
        {
            _builder.AppendLine();
            CreateArguments(_builder, i);
        }
    }

    private void GenerateCallOriginalMethod(MethodInfo data)
    {
        using var line = _builder.StartLine();
        if (data.ReturnsKind != ReturnKind.ReturnsVoid)
        {
            line.AddSegment("return ");
        }

        if (data.ReturnsKind == ReturnKind.ReturnsRef)
        {
            line.AddSegment("ref ");
        }

        line.AddSegment(data.MethodName);
        AddTypeConstraints(data, line);
        var fixedParameters = data.GetFixedParameters().Select(static e => e.ToPassParameter());
        line.AddFormatted($"({fixedParameters}, {data.GetArgNameSpanInput()});");
    }

    private static void CreateArguments(SourceBuilder sb, int length)
    {
        sb.AppendLine($"[global::System.Runtime.CompilerServices.InlineArray({length})]");
        sb.AppendLine($"file struct Arguments{length}<T>");
        using (sb.StartBlock())
        {
            CreateArgumentsMembers(sb, length);
        }
    }

    private static void CreateArgumentsMembers(SourceBuilder sb, int length)
    {
        sb.AppendTextLine("public T arg0;");
        sb.AppendLine();
        sb.AppendLine($"public Arguments{length}({Enumerable.Range(0, length).Select(e => $"T value{e}")})");
        using (sb.StartBlock())
        {
            ArgumentsConstructorBody(sb, length);
        }
    }

    private static void ArgumentsConstructorBody(SourceBuilder builder, int length)
    {
        builder.AppendTextLine("arg0 = value0;");
        for (int i = 1; i < length; i++)
        {
            builder.AppendLine($"this[{i}] = value{i};");
        }
    }
}
