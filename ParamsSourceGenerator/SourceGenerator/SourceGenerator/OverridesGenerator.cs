using Foxy.Params.SourceGenerator.Data;
using Foxy.Params.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Foxy.Params.SourceGenerator.SourceGenerator
{
    internal class OverridesGenerator
    {
        private readonly SourceBuilder _sourceBuilder;
        private readonly INamedTypeSymbol _typeInfo;
        private readonly IEnumerable<SuccessfulParamsCandidate> _paramsCandidates;
        private int _maxOverridesMax = 0;
        public OverridesGenerator(INamedTypeSymbol typeInfo, IEnumerable<SuccessfulParamsCandidate> paramsCandidates)
        {
            _sourceBuilder = new SourceBuilder();
            _typeInfo = typeInfo ?? throw new ArgumentNullException(nameof(typeInfo));
            _paramsCandidates = paramsCandidates ?? throw new ArgumentNullException(nameof(paramsCandidates));
        }

        public SourceText Execute()
        {
            _maxOverridesMax = 0;
            _sourceBuilder.Clear();
            _sourceBuilder.AutoGenerated();
            _sourceBuilder.AppendLine();
            _sourceBuilder.NullableEnable();
            _sourceBuilder.AppendLine();
            GenerateNamespace();

            return SourceText.From(_sourceBuilder.ToString(), Encoding.UTF8);
        }

        private void GenerateNamespace()
        {
            AddNamespace(_sourceBuilder, _typeInfo);

            GenerateOverrideClass();
            GenerateArgumentsClass();

            AddNamespaceCloseBlock(_sourceBuilder, _typeInfo);
        }

        private void GenerateOverrideClass()
        {
            var nestLevel = CreateClasses(_typeInfo, _sourceBuilder);

            foreach (var paramsCandidate in _paramsCandidates)
            {
                var maxOverrides = paramsCandidate.MaxOverrides;
                string name = paramsCandidate.MethodSymbol.Name;
                var spanArgumentType = GetSpanArgumentType(paramsCandidate.SpanParam);
                var parameterInfos = GetNonParamsArguments(paramsCandidate.MethodSymbol);
                var fixArguments = parameterInfos.Select(e => e.ToParameter()).ToList();
                var returnsKind = SemanticHelpers.GetReturnsKind(paramsCandidate.MethodSymbol);
                var typeArguments = paramsCandidate.MethodSymbol.TypeArguments.Select(e => e.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)).ToList();
                var typeConstraints = CreateTypeConstraints(paramsCandidate.MethodSymbol.TypeArguments);
                string returnType = CreateReturnTypeFor(paramsCandidate.MethodSymbol);
                var argName = paramsCandidate.SpanParam.Name;
                var argNameSpan = $"{argName}Span";
                var argNameSpanInput = paramsCandidate.SpanParam.RefKind == RefKind.Ref || paramsCandidate.SpanParam.RefKind == RefKind.RefReadOnlyParameter
                    ? $"ref {argNameSpan}"
                    : argNameSpan;
                var isStatic = paramsCandidate.MethodSymbol.IsStatic;

                for (int i = 1; i <= maxOverrides; i++)
                {
                    if (i > 1)
                    {
                        _sourceBuilder.AppendLine();
                    }

                    var variableArguments = Enumerable.Range(0, i).Select(j => $"{spanArgumentType} {argName}{j}");
                    _sourceBuilder.Method(
                        name,
                        fixArguments.Concat(variableArguments),
                        isStatic,
                        returnType,
                        typeArguments,
                        typeConstraints);
                    _sourceBuilder.AppendLine($"var {argName} = new Arguments{i}<{spanArgumentType}>({string.Join(", ", Enumerable.Range(0, i).Select(j => $"{argName}{j}"))});");
                    _sourceBuilder.AppendLine($"var {argNameSpan} = global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref {argName}.arg0, {i});");
                    CreateCallLine(
                        _sourceBuilder,
                        name,
                        parameterInfos,
                        returnsKind,
                        typeArguments,
                        argNameSpanInput);
                    _sourceBuilder.CloseBlock();
                }

                if (paramsCandidate.HasParams)
                {
                    _sourceBuilder.AppendLine();
                    _sourceBuilder.Method(
                        name,
                        fixArguments.Append($"params {spanArgumentType}[] {argName}"),
                        isStatic,
                        returnType,
                        typeArguments,
                        typeConstraints);
                    _sourceBuilder.AppendLine($"var {argNameSpan} = new global::System.ReadOnlySpan<{spanArgumentType}>({argName});");
                    CreateCallLine(
                        _sourceBuilder,
                        name,
                        parameterInfos,
                        returnsKind,
                        typeArguments,
                        argNameSpanInput);
                    _sourceBuilder.CloseBlock();
                }

                _maxOverridesMax = Math.Max(_maxOverridesMax, maxOverrides);
            }

            CloseTimes(_sourceBuilder, nestLevel);
        }

        private void GenerateArgumentsClass()
        {
            for (int i = 1; i <= _maxOverridesMax; i++)
            {
                _sourceBuilder.AppendLine();
                CreateArguments(_sourceBuilder, i);
            }
        }

        private static string CreateReturnTypeFor(IMethodSymbol methodSymbol)
        {
            var returnType = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var isNullable = methodSymbol.ReturnType.NullableAnnotation == NullableAnnotation.Annotated;
            if (methodSymbol.ReturnsByRef)
            {
                return SemanticHelpers.WithModifiers(returnType, RefKind.Ref, isNullable);
            }
            else if (methodSymbol.ReturnsByRefReadonly)
            {
                return SemanticHelpers.WithModifiers(returnType, RefKind.RefReadOnlyParameter, isNullable);
            }

            return SemanticHelpers.WithModifiers(returnType, RefKind.None, isNullable);
        }

        private static List<TypeConstrainInfo> CreateTypeConstraints(ImmutableArray<ITypeSymbol> typeArguments)
        {
            var typeConstraintsList = new List<TypeConstrainInfo>();
            foreach (var typeArg in typeArguments.Cast<ITypeParameterSymbol>())
            {
                var typeConstraints = new List<string>();
                if (typeArg.HasUnmanagedTypeConstraint)
                {
                    typeConstraints.Add("unmanaged");
                }
                else if (typeArg.HasValueTypeConstraint)
                {
                    typeConstraints.Add("struct");
                }
                else if (typeArg.HasReferenceTypeConstraint)
                {
                    typeConstraints.Add("class");
                }
                else if (typeArg.HasNotNullConstraint)
                {
                    typeConstraints.Add("notnull");
                }
                if (typeArg.ConstraintTypes.Length > 0)
                {
                    foreach (var item in typeArg.ConstraintTypes)
                    {
                        typeConstraints.Add(item.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    }
                }
                if (typeArg.HasConstructorConstraint)
                {
                    typeConstraints.Add("new()");
                }
                if (typeConstraints.Count > 0)
                {
                    typeConstraintsList.Add(new TypeConstrainInfo
                    {
                        Type = typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        Constraints = typeConstraints
                    });
                }
            }
            return typeConstraintsList;
        }

        private static void CreateCallLine(
            SourceBuilder sb,
            string name,
            List<ParameterInfo> parameterInfos,
            ReturnKind returnsKind,
            List<string> typeArguments,
            string paramsArgument)
        {
            var codeLine = sb.StartLine();
            if (returnsKind != ReturnKind.ReturnsVoid)
            {
                codeLine.Returns();
            }
            if (returnsKind == ReturnKind.ReturnsRef)
            {
                codeLine.AddSegment("ref ");
            }
            codeLine.AddSegment(name);
            if (typeArguments.Count > 0)
            {
                codeLine.AddSegment("<");
                codeLine.AddCommaSeparatedList(typeArguments);
                codeLine.AddSegment(">");
            }
            codeLine.AddSegment("(");
            codeLine.AddCommaSeparatedList(parameterInfos.Select(e => e.ToPassParameter()));
            codeLine.AddSegment($", {paramsArgument})");
            codeLine.EndLine();
        }

        private static string GetSpanArgumentType(IParameterSymbol spanParam)
        {
            var spanType = spanParam.Type as INamedTypeSymbol;
            SemanticHelpers.AssertNotNull(spanType);
            var spanTypeArgument = spanType.TypeArguments.First();
            string spanTypeName = spanTypeArgument.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            bool isNullable = spanTypeArgument.NullableAnnotation == NullableAnnotation.Annotated;
            return SemanticHelpers.WithModifiers(spanTypeName, RefKind.None, isNullable);
        }

        private static List<ParameterInfo> GetNonParamsArguments(IMethodSymbol methodSymbol)
        {
            return methodSymbol.Parameters
                .Take(methodSymbol.Parameters.Length - 1)
                .Select(arg => new ParameterInfo(arg))
                .ToList();
        }

        private static void CreateArguments(SourceBuilder sb, int length)
        {
            sb.Attribute($"System.Runtime.CompilerServices.InlineArray({length})");
            sb.GenericStruct($"Arguments{length}", "T");
            sb.Field("T", "arg0");
            sb.AppendLine();
            sb.Constructor(Enumerable.Range(0, length).Select(e => $"T value{e}"));
            sb.AppendLine($"arg0 = value0;");
            for (int i = 1; i < length; i++)
            {
                sb.AppendLine($"this[{i}] = value{i};");
            }
            sb.CloseBlock();
            sb.CloseBlock();
        }

        private static int CreateClasses(INamedTypeSymbol? typeInfo, SourceBuilder sb)
        {
            var items = SemanticHelpers.GetTypeHierarchy(typeInfo);
            foreach (var item in items)
            {
                sb.Class(item.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
            }

            return items.Count;
        }

        private static void CloseTimes(SourceBuilder sb, int nestLevel)
        {
            for (int i = 0; i < nestLevel; i++)
            {
                sb.CloseBlock();
            }
        }

        private static void AddNamespace(SourceBuilder sb, INamedTypeSymbol typeInfo)
        {
            if (typeInfo.ContainingNamespace.IsGlobalNamespace)
                return;

            sb.Namespace(SemanticHelpers.GetNameSpaceNoGlobal(typeInfo));
        }

        private static void AddNamespaceCloseBlock(SourceBuilder sb, INamedTypeSymbol typeInfo)
        {
            if (typeInfo.ContainingNamespace.IsGlobalNamespace)
                return;

            sb.CloseBlock();
        }
    }
}
