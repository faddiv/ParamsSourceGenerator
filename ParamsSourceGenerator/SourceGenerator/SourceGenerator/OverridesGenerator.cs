using Foxy.Params.SourceGenerator.Data;
using Foxy.Params.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Foxy.Params.SourceGenerator.SourceGenerator;

internal static class OverridesGenerator
{
    public static SourceText Execute(CandidateTypeInfo typeInfo, IEnumerable<SuccessfulParams> paramsCandidates)
    {
        var _sourceBuilder = new SourceBuilder();
        var _typeInfo = typeInfo ?? throw new ArgumentNullException(nameof(typeInfo));
        var _paramsCandidates = paramsCandidates ?? throw new ArgumentNullException(nameof(paramsCandidates));
        var _maxOverridesMax = paramsCandidates.Max(e => e.MaxOverrides);

        _sourceBuilder.AutoGeneratedComment();
        _sourceBuilder.AppendLine();
        _sourceBuilder.NullableEnable();
        _sourceBuilder.AppendLine();
        GenerateNamespace(_sourceBuilder, _typeInfo, _paramsCandidates, _maxOverridesMax);

        return SourceText.From(_sourceBuilder.ToString(), Encoding.UTF8);
    }

    private static void GenerateNamespace(SourceBuilder builder, CandidateTypeInfo _typeInfo, IEnumerable<SuccessfulParams> paramsCandidates, int maxOverridesMax)
    {
        if (_typeInfo.InGlobalNamespace)
        {
            GenerateNamespaceMembers(builder, (_typeInfo, paramsCandidates, maxOverridesMax));
        }
        else
        {
            string namespaceName = _typeInfo.Namespace;
            builder.AddNamespaceHeader(namespaceName);
            builder.AddBlock(GenerateNamespaceMembers,
                (_typeInfo, paramsCandidates, maxOverridesMax));
        }
    }

    private static void GenerateNamespaceMembers(
        SourceBuilder builder,
        (CandidateTypeInfo typeInfo,
        IEnumerable<SuccessfulParams> paramsCandidates,
        int maxOverridesMax) args)
    {
        GeneratePartialClass(builder, args.typeInfo, args.paramsCandidates);
        GenerateArgumentsClasses(builder, args.maxOverridesMax);
    }

    private static void GeneratePartialClass(SourceBuilder builder, CandidateTypeInfo _typeInfo, IEnumerable<SuccessfulParams> paramsCandidates)
    {
        var nestLevel = CreateClasses(_typeInfo, builder);

        foreach (var paramsCandidate in paramsCandidates)
        {
            var data = paramsCandidate.DerivedData;

            for (int n = 1; n <= paramsCandidate.MaxOverrides; n++)
            {
                if (n > 1)
                {
                    builder.AppendLine();
                }

                var variableArguments = data.FixArguments.Concat(
                    Enumerable.Range(0, n).Select(j => $"{data.SpanArgumentType} {data.ArgName}{j}"));
                GenerateMethodHeaderWithArguments(builder, data, variableArguments);
                builder.AddBlock(GenerateBodyForOverrideWithNArgs, (data, n));
            }

            if (paramsCandidate.HasParams)
            {
                builder.AppendLine();
                GenerateMethodHeaderWithArguments(builder, data, data.FixArguments.Append($"params {data.SpanArgumentType}[] {data.ArgName}"));
                builder.AddBlock(GenerateBodyWithParamsParameter, data);
            }
        }

        CloseTimes(builder, nestLevel);
    }

    private static int CreateClasses(CandidateTypeInfo typeInfo, SourceBuilder sb)
    {
        var items = typeInfo.TypeHierarchy;
        foreach (var item in items)
        {
            sb.AddClassHeader(item);
            sb.OpenBlock();
        }

        return items.Length;
    }

    private static void CloseTimes(SourceBuilder sb, int nestLevel)
    {
        for (int i = 0; i < nestLevel; i++)
        {
            sb.CloseBlock();
        }
    }

    private static void GenerateMethodHeaderWithArguments(SourceBuilder builder, DerivedData data, IEnumerable<string> arguments)
    {
        builder.Method(
            data.MethodName,
            arguments,
            data.IsStatic,
            data.ReturnType,
            data.TypeArguments,
            data.TypeConstraints);
    }

    private static void GenerateBodyForOverrideWithNArgs(
        SourceBuilder builder,
        (DerivedData data, int argsCount) args)
    {
        GenerateArgumentsVariable(builder, args.data, args.argsCount);
        GenerateSpanVariableForInlineArray(builder, args.data, args.argsCount);
        GenerateCallOriginalMethod(builder, args.data);
    }

    private static void GenerateSpanVariableForInlineArray(SourceBuilder builder, DerivedData data, int argsCount)
    {
        builder.AppendLine($"var {data.ArgNameSpan} = global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref {data.ArgName}.arg0, {argsCount});");
    }

    private static void GenerateArgumentsVariable(SourceBuilder builder, DerivedData data, int argsCount)
    {
        builder.AppendLine($"var {data.ArgName} = new Arguments{argsCount}<{data.SpanArgumentType}>({string.Join(", ", Enumerable.Range(0, argsCount).Select(j => $"{data.ArgName}{j}"))});");
    }

    private static void GenerateBodyWithParamsParameter(SourceBuilder builder, DerivedData data)
    {
        GenerateSpanVariableForParamsArgument(builder, data);
        GenerateCallOriginalMethod(builder, data);
    }

    private static void GenerateSpanVariableForParamsArgument(SourceBuilder builder, DerivedData data)
    {
        builder.AppendLine($"var {data.ArgNameSpan} = new global::System.ReadOnlySpan<{data.SpanArgumentType}>({data.ArgName});");
    }

    private static void GenerateArgumentsClasses(SourceBuilder builder, int maxOverridesMax)
    {
        for (int i = 1; i <= maxOverridesMax; i++)
        {
            builder.AppendLine();
            CreateArguments(builder, i);
        }
    }

    private static void GenerateCallOriginalMethod(SourceBuilder builder, DerivedData data)
    {
        var codeLine = builder.StartLine();
        if (data.ReturnsKind != ReturnKind.ReturnsVoid)
        {
            codeLine.Returns();
        }
        if (data.ReturnsKind == ReturnKind.ReturnsRef)
        {
            codeLine.AddSegment("ref ");
        }
        codeLine.AddSegment(data.MethodName);
        if (data.TypeArguments.Count > 0)
        {
            codeLine.AddSegment("<");
            codeLine.AddCommaSeparatedList(data.TypeArguments);
            codeLine.AddSegment(">");
        }
        codeLine.AddSegment("(");
        codeLine.AddCommaSeparatedList(data.ParameterInfos.Select(e => e.ToPassParameter()));
        codeLine.AddSegment($", {data.ArgNameSpanInput})");
        codeLine.EndLine();
    }

    private static void CreateArguments(SourceBuilder sb, int length)
    {
        sb.Attribute($"System.Runtime.CompilerServices.InlineArray({length})");
        string name = $"Arguments{length}";
        sb.AddGenericStruct(name, "T");
        sb.AddNamedBlock(name, CreateArgumentsMembers, length);

    }

    private static void CreateArgumentsMembers(SourceBuilder sb, int length)
    {
        sb.Field("T", "arg0");
        sb.AppendLine();
        sb.AddConstructorHeader(Enumerable.Range(0, length).Select(e => $"T value{e}"));
        sb.AddBlock(ArgumentsConstructorBody, length);
    }

    private static void ArgumentsConstructorBody(SourceBuilder builder, int length)
    {
        builder.AppendLine($"arg0 = value0;");
        for (int i = 1; i < length; i++)
        {
            builder.AppendLine($"this[{i}] = value{i};");
        }
    }
}
