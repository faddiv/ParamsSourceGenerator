using Foxy.Params.SourceGenerator.Data;
using Foxy.Params.SourceGenerator.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Foxy.Params.SourceGenerator.SourceGenerator
{
    internal class OverridesGenerator
    {
        private readonly SourceBuilder _sourceBuilder;
        private readonly INamedTypeSymbol _typeInfo;
        private readonly IEnumerable<SuccessfulParamsCandidate> _paramsCandidates;
        private readonly int _maxOverridesMax;

        public OverridesGenerator(INamedTypeSymbol typeInfo, IEnumerable<SuccessfulParamsCandidate> paramsCandidates)
        {
            _sourceBuilder = new SourceBuilder();
            _typeInfo = typeInfo ?? throw new ArgumentNullException(nameof(typeInfo));
            _paramsCandidates = paramsCandidates ?? throw new ArgumentNullException(nameof(paramsCandidates));
            _maxOverridesMax = paramsCandidates.Max(e => e.MaxOverrides);
        }

        public SourceText Execute()
        {
            _sourceBuilder.Clear();
            _sourceBuilder.AppendTrivias(
                AutoGeneratedComment(),
                CarriageReturnLineFeed,
                NullableEnable(),
                CarriageReturnLineFeed);
            GenerateNamespace();

            return SourceText.From(_sourceBuilder.ToString(), Encoding.UTF8);
        }

        private static SyntaxTrivia AutoGeneratedComment()
        {
            return Comment("// <auto-generated />");
        }

        private static SyntaxTrivia NullableEnable()
        {
            return Trivia(
                NullableDirectiveTrivia(
                    Token(TriviaList(Space), SyntaxKind.EnableKeyword, TriviaList()),
                    true));
        }

        private void GenerateNamespace()
        {
            AddNamespace(_sourceBuilder, _typeInfo);

            GeneratePartialClass();
            GenerateArgumentsClasses();

            AddNamespaceCloseBlock(_sourceBuilder, _typeInfo);
        }

        private void GeneratePartialClass()
        {
            var nestLevel = CreateClasses(_typeInfo, _sourceBuilder);

            foreach (var paramsCandidate in _paramsCandidates)
            {
                var data = new DerivedData(paramsCandidate);

                for (int n = 1; n <= paramsCandidate.MaxOverrides; n++)
                {
                    if (n > 1)
                    {
                        _sourceBuilder.AppendLine();
                    }

                    GenerateMethodOverrideWithNArgs(data, n);
                }

                GenerateOverrideWithParamsParameter(paramsCandidate, data);
            }

            CloseTimes(_sourceBuilder, nestLevel);
        }

        private static int CreateClasses(INamedTypeSymbol? typeInfo, SourceBuilder sb)
        {
            var items = SemanticHelpers.GetTypeHierarchy(typeInfo);
            foreach (var item in items)
            {
                sb.Class(item.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat));
            }

            return items.Count;
        }

        private static void CloseTimes(SourceBuilder sb, int nestLevel)
        {
            for (int i = 0; i < nestLevel; i++)
            {
                sb.CloseBlock();
            }
        }

        private void GenerateMethodOverrideWithNArgs(DerivedData data, int argsCount)
        {
            var variableArguments = data.FixArguments.Concat(
                Enumerable.Range(0, argsCount).Select(j => $"{data.SpanArgumentType} {data.ArgName}{j}"));
            GenerateMethodHeaderWithArguments(data, variableArguments);
            GenerateBodyForOverrideWithNArgs(data, argsCount);
            _sourceBuilder.CloseBlock();
        }

        private void GenerateMethodHeaderWithArguments(DerivedData data, IEnumerable<string> arguments)
        {
            _sourceBuilder.Method(
                data.MethodName,
                arguments,
                data.IsStatic,
                data.ReturnType,
                data.TypeArguments,
                data.TypeConstraints);
        }

        private void GenerateBodyForOverrideWithNArgs(DerivedData data, int argsCount)
        {
            GenerateArgumentsVariable(data, argsCount);
            GenerateSpanVariableForInlineArray(data, argsCount);
            GenerateCallOriginalMethod(data);
        }


        /// <summary>
        /// var {argsSpan} = global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref {arg}.arg0, {argsCount});
        /// </summary>
        private void GenerateSpanVariableForInlineArray(DerivedData data, int argsCount)
        {
            var variableDeclaration = SimpleVarDeclaration(
                VariableDeclarator(
                    Identifier(data.ArgNameSpan),
                    null,
                    EqualsValueClause(CallCreateReadOnlySpan(data.ArgName, argsCount))));
            _sourceBuilder.AppendBlockLine(variableDeclaration);
        }

        /// <summary>
        /// global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref args.arg0, 1)
        /// </summary>
        private ExpressionSyntax CallCreateReadOnlySpan(string argName, int argsCount)
        {
            return InvocationExpression(
                GlobalMemberAccessChain(["System", "Runtime", "InteropServices", "MemoryMarshal", "CreateReadOnlySpan"]),
                Arguments([
                    QualifiedArgument(MemberAccessChain([argName, "arg0"]), SyntaxKind.RefKeyword),
                    Argument(SimpleLiteral(argsCount))
                    ])
                );
        }

        /// <summary>
        /// {intValue}
        /// </summary>
        private static LiteralExpressionSyntax SimpleLiteral(int value)
        {
            return LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value));
        }

        private void GenerateArgumentsVariable(DerivedData data, int argsCount)
        {
            _sourceBuilder.AppendLine($"var {data.ArgName} = new Arguments{argsCount}<{data.SpanArgumentType}>({string.Join(", ", Enumerable.Range(0, argsCount).Select(j => $"{data.ArgName}{j}"))});");
        }

        private void GenerateOverrideWithParamsParameter(SuccessfulParamsCandidate paramsCandidate, DerivedData data)
        {
            if (!paramsCandidate.HasParams)
            {
                return;
            }
            _sourceBuilder.AppendLine();
            GenerateMethodHeaderWithArguments(data, data.FixArguments.Append($"params {data.SpanArgumentType}[] {data.ArgName}"));
            GenerateBodyWithParamsParameter(data);
            _sourceBuilder.CloseBlock();
        }

        private void GenerateBodyWithParamsParameter(DerivedData data)
        {
            GenerateSpanVariableForParamsArgument(data);
            GenerateCallOriginalMethod(data);
        }

        /// <summary>
        /// var {argsSpan} = new global::System.ReadOnlySpan<{T}>({args});
        /// </summary>
        private void GenerateSpanVariableForParamsArgument(DerivedData data)
        {
            var variableDeclaration = SimpleVarDeclaration(
                VariableDeclarator(
                    Identifier(data.ArgNameSpan),
                    null,
                    EqualsValueClause(NewReadOnlySpanOfTWithArgs(data.SpanArgumentType, data.ArgName))));
            _sourceBuilder.AppendBlockLine(variableDeclaration);
        }

        /// <summary>
        /// new global::System.ReadOnlySpan&lt;T&gt;(argName)
        /// </summary>
        private static ObjectCreationExpressionSyntax NewReadOnlySpanOfTWithArgs(string spanArgumentType, string argName)
        {
            return ObjectCreationExpression(
                ToGloballyQualifiedName("System", GenericName(Identifier("ReadOnlySpan"), TypeArguments(spanArgumentType))),
                Arguments(IdentifierName(argName)),
                null);
        }

        /// <summary>
        /// {argumentTypeName}
        /// </summary>
        private static TypeArgumentListSyntax TypeArguments(string argumentTypeName)
        {
            return TypeArgumentList(SingletonSeparatedList(ParseTypeName(argumentTypeName)));
        }

        /// <summary>
        /// {typeParameterName}
        /// </summary>
        private static TypeParameterListSyntax TypeParameters(string typeParameterName)
        {
            return TypeParameterList(SingletonSeparatedList(TypeParameter(typeParameterName)));
        }

        /// <summary>
        /// {arg} (In argument list)
        /// </summary>
        private static ArgumentListSyntax Arguments(ExpressionSyntax arg)
        {
            return ArgumentList(SingletonSeparatedList(Argument(arg)));
        }

        /// <summary>
        /// <code>ref {arg}</code>
        /// or
        /// <code>in {arg}</code>
        /// or
        /// <code>out {arg}</code>
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException">not None, ref, in or out.</exception>
        private static ArgumentSyntax QualifiedArgument(ExpressionSyntax arg, SyntaxKind syntaxKind = SyntaxKind.None)
        {
            return syntaxKind switch
            {
                SyntaxKind.None => Argument(arg),
                SyntaxKind.RefKeyword or
                SyntaxKind.OutKeyword or
                SyntaxKind.InKeyword => Argument(default, Token(syntaxKind), arg),
                _ => throw new ArgumentOutOfRangeException(nameof(syntaxKind)),
            };
        }

        /// <summary>
        /// {arg0}, {arg1}, {arg2}
        /// </summary>
        private static ArgumentListSyntax Arguments(IEnumerable<ArgumentSyntax> args)
        {
            return ArgumentList(SeparatedList(args));
        }

        private static QualifiedNameSyntax ToGloballyQualifiedName(string qualifier, SimpleNameSyntax nameSyntax)
        {
            return QualifiedName(
                        GlobalNameSyntax(qualifier), nameSyntax);
        }

        /// <summary>
        /// global::{parts[0]}.{parts[1]}.{parts[2]}
        /// </summary>
        private static ExpressionSyntax GlobalMemberAccessChain(
            string[] parts)
        {
            return MemberAccessChain(parts, isGlobal: true);
        }

        /// <summary>
        /// {parts[0]}.{parts[1]}.{parts[2]}
        /// </summary>
        private static ExpressionSyntax MemberAccessChain(
            string[] parts, bool isGlobal = false)
        {
            ExpressionSyntax current = isGlobal
                ? GlobalNameSyntax(parts[0])
                : IdentifierName(parts[0]);
            for (int i = 1; i < parts.Length; i++)
            {
                current = MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    current,
                    IdentifierName(parts[i]));
            }
            return current;
        }

        /// <summary>
        /// global::{qualifier}
        /// </summary>
        private static AliasQualifiedNameSyntax GlobalNameSyntax(string qualifier)
        {
            return AliasQualifiedName(
                IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                IdentifierName(qualifier));
        }

        private static NameSyntax GlobalNameSyntax(params string[] qualifiers)
        {
            NameSyntax result = GlobalNameSyntax(qualifiers[0]);
            for(int i = 1;i < qualifiers.Length; i++)
            {
                result = QualifiedName(
                        result,
                        IdentifierName(qualifiers[i]));
            }
            return result;
        }

        /// <summary>
        /// var {varDeclarator}
        /// </summary>
        private static VariableDeclarationSyntax SimpleVarDeclaration(VariableDeclaratorSyntax varDeclarator)
        {
            return VariableDeclaration(VarIdentifier(), SingletonSeparatedList(varDeclarator));
        }

        /// <summary>
        /// var
        /// </summary>
        private static IdentifierNameSyntax VarIdentifier()
        {
            return IdentifierName(Identifier("var"));
        }

        private void GenerateArgumentsClasses()
        {
            for (int i = 1; i <= _maxOverridesMax; i++)
            {
                _sourceBuilder.AppendLine();
                CreateArgumentsStruct(_sourceBuilder, i);
            }
        }

        /// <summary>
        /// return Format<{T}>({format}, {argsSpan})
        /// </summary>
        private void GenerateCallOriginalMethod(DerivedData data)
        {
            SimpleNameSyntax methodName = data.TypeArguments.Count > 0
                ? GenericName(Identifier(data.MethodName), TypeArgumentList(SeparatedList(GenerateInvocationTypeArguments(data))))
                : IdentifierName(data.MethodName);
            SyntaxNode invocationExpression = InvocationExpression(
                methodName,
                ArgumentList(SeparatedList(GenerateInvocationArguments(data))));
            invocationExpression = AddReturnStatement(data.ReturnsKind, invocationExpression);
            _sourceBuilder.AppendBlockLine(invocationExpression);
        }

        /// <summary>
        /// <code>Format()</code> 
        /// or
        /// <code>return Format()</code>
        /// or
        /// <code>return ref Format()</code>
        /// </summary>
        private static SyntaxNode AddReturnStatement(ReturnKind returnKind, SyntaxNode invocationExpression)
        {
            if (returnKind == ReturnKind.ReturnsRef)
            {
                invocationExpression = RefExpression((ExpressionSyntax)invocationExpression);
            }
            if (returnKind != ReturnKind.ReturnsVoid)
            {
                invocationExpression = ReturnStatement((ExpressionSyntax)invocationExpression);
            }

            return invocationExpression;
        }

        private IEnumerable<TypeSyntax> GenerateInvocationTypeArguments(DerivedData data)
        {
            foreach (var item in data.TypeArguments)
            {
                yield return IdentifierName(item);
            }
        }

        private IEnumerable<ArgumentSyntax> GenerateInvocationArguments(DerivedData data)
        {
            foreach (var item in data.ParameterInfos)
            {
                var argument = Argument(IdentifierName(item.Name));

                switch (item.GetPassParameterModifier())
                {
                    case RefKind.Ref:
                        argument = argument.WithRefKindKeyword(Token(SyntaxKind.RefKeyword));
                        break;
                    case RefKind.Out:
                        argument = argument.WithRefKindKeyword(Token(SyntaxKind.OutKeyword));
                        break;
                    case RefKind.In:
                        argument = argument.WithRefKindKeyword(Token(SyntaxKind.InKeyword));
                        break;
                    default:
                        break;
                }

                yield return argument;
            }
            var argSpan = Argument(IdentifierName(data.ArgNameSpanInput));
            yield return argSpan;
        }

        private static void CreateArgumentsStruct(SourceBuilder sb, int length)
        {
            var typeName = Identifier($"Arguments{length}");
            var arguments = StructDeclaration(
                attributeLists: Attributes(InlineArrayAttribute(length)),
                modifiers: Modifiers(SyntaxKind.FileKeyword),
                identifier: typeName,
                typeParameterList: TypeParameters("T"),
                baseList: default,
                constraintClauses: default,
                members: ArgumentsStructMembers(length, typeName));
            arguments = arguments.NormalizeWhitespace();
            arguments = arguments.AddEmptyLineAfterMember(arguments.Members[0]);
            sb.AppendBlockLine(arguments, false);
        }

        private static SyntaxList<MemberDeclarationSyntax> ArgumentsStructMembers(int length, SyntaxToken typeName)
        {
            return List(ArgumentsStructMembers(typeName, length));

            static IEnumerable<MemberDeclarationSyntax> ArgumentsStructMembers(SyntaxToken typeName, int argumentsCount)
            {
                yield return PublicField(IdentifierName("T"), "arg0");
                yield return ArgumentsTypeCtor(typeName, argumentsCount);
            }

        }

        private static MemberDeclarationSyntax ArgumentsTypeCtor(SyntaxToken typeName, int argumentsCount)
        {
            return ConstructorDeclaration(
                attributeLists: default,
                modifiers: Modifiers(SyntaxKind.PublicKeyword),
                identifier: typeName,
                parameterList: ArgumentsTypeCtorParameters(argumentsCount),
                initializer: default,
                body: ArgumentsTypeCtorBody(argumentsCount));
        }

        private static ParameterListSyntax ArgumentsTypeCtorParameters(int argumentsCount)
        {
            return ParameterList(SeparatedList(ArgumentsTypeCtorEnumerator(argumentsCount)));

            static IEnumerable<ParameterSyntax>? ArgumentsTypeCtorEnumerator(int argumentsCount)
            {
                for (int i = 0; i < argumentsCount; i++)
                {
                    yield return Parameter(Identifier($"value{i}"))
                        .WithType(IdentifierName("T"));
                }
            }
        }

        private static BlockSyntax ArgumentsTypeCtorBody(int argumentsCount)
        {
            return Block(ArgumentsTypeCtorBodyEnumerator(argumentsCount));

            static IEnumerable<StatementSyntax> ArgumentsTypeCtorBodyEnumerator(int argumentsCount)
            {
                yield return SimpleAssignmentLine(IdentifierName("arg0"), IdentifierName("value0"));
                for (int i = 1; i < argumentsCount; i++)
                {
                    yield return SimpleAssignmentLine(
                        ElementAccessExpression(ThisExpression(), Indexer(i)),
                        IdentifierName($"value{i}"));
                }
            }
        }

        private static FieldDeclarationSyntax PublicField(TypeSyntax type, string identifier)
        {
            return FieldDeclaration(
                attributeLists: default,
                modifiers: Modifiers(SyntaxKind.PublicKeyword),
                VariableDeclaration(
                    type,
                    SingletonSeparatedList(VariableDeclarator(Identifier(identifier)))));
        }

        /// <summary>
        /// left = right;
        /// </summary>
        private static ExpressionStatementSyntax SimpleAssignmentLine(ExpressionSyntax left, ExpressionSyntax right)
        {
            return ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, left, right));
        }

        /// <summary>
        /// ?[index]
        /// </summary>
        private static BracketedArgumentListSyntax Indexer(int index)
        {
            return Indexer(SimpleLiteral(index));
        }
        /// <summary>
        /// ?[expressionSyntax]
        /// </summary>
        private static BracketedArgumentListSyntax Indexer(ExpressionSyntax expressionSyntax)
        {
            return BracketedArgumentList(
                SingletonSeparatedList(
                    Argument(expressionSyntax)));
        }

        /// <summary>
        /// modifier ?
        /// </summary>
        private static SyntaxTokenList Modifiers(SyntaxKind modifier)
        {
            return TokenList(Token(modifier));
        }

        /// <summary>
        /// [attribute]<br/>
        /// ?
        /// </summary>
        private static SyntaxList<AttributeListSyntax> Attributes(AttributeSyntax attribute) {
            return SingletonList(AttributeList(SingletonSeparatedList(attribute)));
        }

        /// <summary>
        /// [global::System.Runtime.CompilerServices.InlineArray(length)]<br/>
        /// ?
        /// </summary>
        private static AttributeSyntax InlineArrayAttribute(int length)
        {
            return Attribute(
                GlobalNameSyntax("System", "Runtime", "CompilerServices", "InlineArray"),
                AttributeArgumentList(SingletonSeparatedList(AttributeArgument(SimpleLiteral(length))
                )));
        }

        private static void AddNamespace(SourceBuilder sb, INamedTypeSymbol typeInfo)
        {
            if (typeInfo.ContainingNamespace.IsGlobalNamespace)
                return;

            /*var name = ParseName(SemanticHelpers.GetNameSpaceNoGlobal(typeInfo));
            var @namespace = NamespaceDeclaration(name);
            sb.AppendTrivia(@namespace);*/

            sb.Namespace(SemanticHelpers.GetNameSpaceNoGlobal(typeInfo));
        }

        private static void AddNamespaceCloseBlock(SourceBuilder sb, INamedTypeSymbol typeInfo)
        {
            if (typeInfo.ContainingNamespace.IsGlobalNamespace)
                return;

            sb.CloseBlock();
        }
    }
}
